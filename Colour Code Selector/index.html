<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Color Picker Tool</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      margin: 0;
      background-color: #f0f0f0;
      touch-action: none;
      padding: 20px;
      overflow-y: auto;
    }
    
    .color-picker-container {
      text-align: center;
      background: #ffffff;
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0px 4px 12px rgba(0, 0, 0, 0.1);
      width: 340px;
      overflow-y: auto;
    }
    
    h2 {
      font-size: 24px;
      margin-bottom: 30px;
    }

    input[type="range"] {
      -webkit-appearance: none;
      width: 100%;
      height: 16px;
      background: linear-gradient(to right, red, yellow, lime, cyan, blue, magenta);
      border-radius: 10px;
      outline: none;
      margin-bottom: 50px;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: white;
      cursor: pointer;
      box-shadow: 0px 0px 3px rgba(0, 0, 0, 0.6);
    }

    .gradient-container {
      position: relative;
      width: 100%;
      height: 150px;
      margin: 25px 0;
      touch-action: none;
      border-radius: 8px;
      overflow: hidden;
      border: 1px solid #ccc;
    }

    .gradient-shade {
      width: 100%;
      height: 100%;
      background: white;
      cursor: crosshair;
      touch-action: none;
    }

    .selector-pointer {
      position: absolute;
      width: 10px;
      height: 10px;
      border: 2px solid white;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      cursor: move;
      box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.5);
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
      transition: transform 0.1s ease;
    }

    .selector-pointer:active {
      transform: translate(-50%, -50%) scale(1.2);
    }

    .color-preview {
      font-size: 20px;
      font-weight: bold;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 5px;
      margin: 10px auto;
      width: 150px;
      text-align: center;
    }

    .color-values {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-top: 10px;
      flex-wrap: wrap;
    }

    .color-value {
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
      background: #f5f5f5;
    }

    .color-palette {
      margin-top: 30px;
      border-top: 1px solid #eee;
      padding-top: 20px;
    }

    .palette-row {
      display: flex;
      align-items: center;
      margin: 8px 0;
      padding: 8px;
      border-radius: 4px;
      transition: background-color 0.2s;
      transition: transform 0.3s;
    }

    .palette-row:hover {
      background-color: #f5f5f5;
      transform: scale(1.11);
    }

    .palette-color {
      width: 75px;
      height: 45px;
      border-radius: 4px;
      border: 1px solid #ccc;
      margin-right: 20px;
      flex-shrink: 0;
    }

    .palette-info {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 4px;
      flex-grow: 1;
      font-size: 12px;
    }

    .palette-hex {
      font-weight: bold;
      font-size: 16px;
    }

    .palette-rgb,
    .palette-hsl {
      color: #666;
    }
  </style>
</head>
<body>
  <div class="color-picker-container">
    <h2>Pick Colour</h2>
    
    <div class="gradient-container">
      <canvas class="gradient-shade" id="gradientShadeCanvas"></canvas>
      <div class="selector-pointer" id="selectorPointer"></div>
    </div>
    
    <input type="range" min="0" max="360" value="0" id="hueSlider">
    
    <div class="color-preview" id="colorPreview">#FFFFFF</div>
    <div class="color-values">
      <div class="color-value" id="rgbValue">RGB(255, 255, 255)</div>
      <div class="color-value" id="hslValue">HSL(0, 0%, 100%)</div>
    </div>

    <div class="color-palette" id="colorPalette"></div>
  </div>
  
  <script>
    const hueSlider = document.getElementById("hueSlider");
    const gradientShadeCanvas = document.getElementById("gradientShadeCanvas");
    const colorPreview = document.getElementById("colorPreview");
    const selectorPointer = document.getElementById("selectorPointer");
    const rgbValue = document.getElementById("rgbValue");
    const hslValue = document.getElementById("hslValue");
    const gradientContainer = document.querySelector('.gradient-container');
    const colorPalette = document.getElementById("colorPalette");

    const ctx = gradientShadeCanvas.getContext("2d", { willReadFrequently: true });
    gradientShadeCanvas.width = 300;
    gradientShadeCanvas.height = 150;

    let selectedHue = 0;
    let isDragging = false;
    let currentX = 0;
    let currentY = 0;
    let startX, startY;

    function setShadeGradient() {
      const width = gradientShadeCanvas.width;
      const height = gradientShadeCanvas.height;

      const gradient = ctx.createLinearGradient(0, 0, width, 0);
      gradient.addColorStop(0, "white");
      gradient.addColorStop(1, `hsl(${selectedHue}, 100%, 50%)`);
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, width, height);

      const blackGradient = ctx.createLinearGradient(0, 0, 0, height);
      blackGradient.addColorStop(0, "rgba(0, 0, 0, 0)");
      blackGradient.addColorStop(1, "rgba(0, 0, 0, 1)");
      ctx.fillStyle = blackGradient;
      ctx.fillRect(0, 0, width, height);
    }

    function rgbToHsl(r, g, b) {
      r /= 255;
      g /= 255;
      b /= 255;
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      let h, s, l = (max + min) / 2;

      if (max === min) {
        h = s = 0;
      } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r: h = (g - b) / d + (g < b ? 6 : 0); break;
          case g: h = (b - r) / d + 2; break;
          case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
      }

      return [
        Math.round(h * 360),
        Math.round(s * 100),
        Math.round(l * 100)
      ];
    }

    function hslToRgb(h, s, l) {
      h /= 360;
      s /= 100;
      l /= 100;
      let r, g, b;

      if (s === 0) {
        r = g = b = l;
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        };

        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }

      return [
        Math.round(r * 255),
        Math.round(g * 255),
        Math.round(b * 255)
      ];
    }

    function generateColorPalette(h, s, l) {
      const colors = [];
      
      // Monochromatic - varying lightness
      for (let i = 0; i < 5; i++) {
        const newL = Math.min(100, Math.max(0, l + (i - 2) * 15));
        colors.push([h, s, newL]);
      }

      // Analogous - varying hue
      for (let i = -2; i <= 2; i++) {
        if (i === 0) continue;
        const newH = (h + i * 30 + 360) % 360;
        colors.push([newH, s, l]);
      }

      // Complementary
      colors.push([(h + 180) % 360, s, l]);

      // Split complementary
      colors.push([(h + 150) % 360, s, l]);
      colors.push([(h + 210) % 360, s, l]);

      // Triadic
      colors.push([(h + 120) % 360, s, l]);
      colors.push([(h + 240) % 360, s, l]);

      // Tetradic
      colors.push([(h + 90) % 360, s, l]);
      colors.push([(h + 270) % 360, s, l]);

      // Varying saturation
      for (let i = 1; i <= 4; i++) {
        const newS = Math.min(100, Math.max(0, s + (i - 2) * 25));
        colors.push([h, newS, l]);
      }

      return colors;
    }

    function updateColorPalette(h, s, l) {
      const colors = generateColorPalette(h, s, l);
      colorPalette.innerHTML = '';

      colors.forEach(([h, s, l]) => {
        const rgb = hslToRgb(h, s, l);
        const hex = rgbToHex(...rgb);

        const row = document.createElement('div');
        row.className = 'palette-row';

        const colorBox = document.createElement('div');
        colorBox.className = 'palette-color';
        colorBox.style.backgroundColor = hex;

        const info = document.createElement('div');
        info.className = 'palette-info';
        
        info.innerHTML = `
          <span class="palette-hex">${hex}</span>
          <span class="palette-rgb">RGB(${rgb.join(', ')})</span>
          <span class="palette-hsl">HSL(${Math.round(h)}, ${Math.round(s)}%, ${Math.round(l)}%)</span>
        `;

        row.appendChild(colorBox);
        row.appendChild(info);
        colorPalette.appendChild(row);
      });
    }

    function updateColorPreview(x, y) {
      x = Math.max(1, Math.min(gradientShadeCanvas.width - 1, x));
      y = Math.max(1, Math.min(gradientShadeCanvas.height - 1, y));

      let r = 0, g = 0, b = 0;
      const sampleSize = 3;
      const halfSample = Math.floor(sampleSize / 2);
      
      for(let offsetY = -halfSample; offsetY <= halfSample; offsetY++) {
        for(let offsetX = -halfSample; offsetX <= halfSample; offsetX++) {
          const sampleX = Math.max(0, Math.min(gradientShadeCanvas.width - 1, x + offsetX));
          const sampleY = Math.max(0, Math.min(gradientShadeCanvas.height - 1, y + offsetY));
          const pixel = ctx.getImageData(sampleX, sampleY, 1, 1).data;
          r += pixel[0];
          g += pixel[1];
          b += pixel[2];
        }
      }
      
      const totalSamples = sampleSize * sampleSize;
      r = Math.round(r / totalSamples);
      g = Math.round(g / totalSamples);
      b = Math.round(b / totalSamples);

      const rgb = `RGB(${r}, ${g}, ${b})`;
      const hexColor = rgbToHex(r, g, b);
      const hsl = rgbToHsl(r, g, b);
      
      colorPreview.textContent = hexColor;
      colorPreview.style.backgroundColor = hexColor;
      colorPreview.style.color = hsl[2] > 50 ? '#000' : '#fff';
      
      rgbValue.textContent = rgb;
      hslValue.textContent = `HSL(${hsl[0]}, ${hsl[1]}%, ${hsl[2]}%)`;

      // Update color palette
      updateColorPalette(hsl[0], hsl[1], hsl[2]);

      selectorPointer.style.left = `${x}px`;
      selectorPointer.style.top = `${y}px`;
      
      currentX = x;
      currentY = y;
    }

    function rgbToHex(r, g, b) {
      const toHex = (n) => {
        const hex = n.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      };
      return `#${toHex(r)}${toHex(g)}${toHex(b)}`.toUpperCase();
    }

    function updateGradient() {
      selectedHue = hueSlider.value;
      setShadeGradient();
      if (currentX || currentY) {
        updateColorPreview(currentX, currentY);
      }
    }

    function positionSelectorTopRight() {
      const margin = 25;
      const x = gradientShadeCanvas.width - margin;
      const y = margin;
      updateColorPreview(x, y);
    }

    function handleStart(e) {
      isDragging = true;
      const rect = gradientContainer.getBoundingClientRect();
      
      const clientX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
      const clientY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY;
      
      startX = parseInt(selectorPointer.style.left) || 0;
      startY = parseInt(selectorPointer.style.top) || 0;
      
      let x = clientX - rect.left;
      let y = clientY - rect.top;
      
      updateColorPreview(x, y);
      
      if (e.type.includes('touch')) {
        e.preventDefault();
      }
    }

    function handleMove(e) {
      if (!isDragging) return;
      
      const rect = gradientContainer.getBoundingClientRect();
      
      const clientX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
      const clientY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY;
      
      let x = clientX - rect.left;
      let y = clientY - rect.top;
      
      updateColorPreview(x, y);
      
      if (e.type.includes('touch')) {
        e.preventDefault();
      }
    }

    function handleEnd() {
      isDragging = false;
    }

    // Mouse events
    gradientContainer.addEventListener('mousedown', handleStart);
    document.addEventListener('mousemove', handleMove);
    document.addEventListener('mouseup', handleEnd);

    // Touch events
    gradientContainer.addEventListener('touchstart', handleStart, { passive: false });
    document.addEventListener('touchmove', handleMove, { passive: false });
    document.addEventListener('touchend', handleEnd);
    document.addEventListener('touchcancel', handleEnd);

    gradientContainer.addEventListener('touchmove', (e) => {
      e.preventDefault();
    }, { passive: false });

    // Add click event listeners to palette rows for copying colors
    colorPalette.addEventListener('click', (e) => {
      const row = e.target.closest('.palette-row');
      if (row) {
        const hexValue = row.querySelector('.palette-hex').textContent;
        navigator.clipboard.writeText(hexValue).then(() => {
          // Visual feedback for copy
          row.style.backgroundColor = '#e6e6e6';
          setTimeout(() => {
            row.style.backgroundColor = '';
          }, 200);
        });
      }
    });

    hueSlider.addEventListener("input", updateGradient);

    // Initialize the gradient on page load
    updateGradient();
    positionSelectorTopRight();
  </script>
</body>
</html>
